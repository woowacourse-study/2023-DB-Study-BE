# 4장. 아키텍처

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/309f7cfb-9f49-4654-b77c-678825ddad8a/Untitled.png)

> **MySQL 서버 ← MySQL 엔진 + 스토리지 엔진**
> 
- 대부분의 프로그래밍 언어로부터 접근 방법 모두 지원

> **MySQL 엔진**: 사람 머리 역할
> 
- 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
- SQL 파서 및 전처리기
- 쿼리 최적화 실행을 이한 옵티마이저
- 표준 SQL 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있음

> **스토리지 엔진**: 손발 역할
> 
- 실제 데이터를 디스크 스토리지에 저장 + 데이터 읽기
- 스토리지 엔진 여러 개 동시 사용 가능
- 성능 향상을 위한 키 캐시(MyISAM), InnoDB 버퍼 풀과 같은 기능 내장
- ex) InnoDB(5.5 이후 기본), MyISAM(5.5 이전 기본), Memory, Archive, CSV, Federated …

> **핸들러 API**
> 
- 스토리지 엔진에 쓰기/읽기 요청에 사용되는 API
- 핸들러 API를 만족하면 누구든 스토리지 엔진을 구현해서 MySQL 서버에 추가하여 사용 가능

## 4.1 **MySQL 엔진** 아키텍처

### MySQL 스레딩 구조

> **프로세스 기반이 아닌 스레드 기반 작동**
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a99e4716-6f4f-4ed2-94a5-aa62a2cbbbf2/Untitled.png)

- Oracle Database: 프로세스 기반 아키텍처 → IPC 메커니즘 사용
- PostgreSQL: 하이브리드 아키텍처(프로세스 기반 아키텍처 + 스레드 기반 아키텍처)

> **포그라운드 스레드(클라이언트 스레드)**
> 
- MySQL 서버에 접속된 클라이언트 수만큼 존재
- 클라이언트가 요청하는 쿼리 문장 처리
- 클라이언트가 작업을 마치고 커넥션을 종료하면 그 스레드는 스레드 캐시로 되돌아감
- 각 스토리지 포그라운드 역할
    - MyISAM 테이블: 디스크 쓰기 작업까지 처리
    - InnoDB 테이블: 데이터 버퍼나 캐시까지만 처리, 디스크 기록은 백그라운드가

> **백그라운드 스레드**
> 
- 인서트 버퍼 병합, 로그 기록, InnoDB 버퍼 풀의 데이터 기록, 데이터를 버퍼로 읽어오기, 잠금이나 데드락 모니터링

### 메모리 할당 및 사용 구조

> **글로벌 메모리 영역**
> 
- 클라이언트 수와 무관하게 주로 1개의 메모리 공간이 할당됨 (N개인 경우에도 모든 스레드에 의해 공유됨)
- 테이블 캐시, (InnoDB) 버퍼 풀 / 어댑티브 해시 인덱스 / 리두 로그 버퍼

> **로컬 메모리 영역 (클라이언트/세션 메모리 영역)**
> 
- 클라이언트 커넥션으로부터의 요청을 처리하기 위해 하나씩 할당 (스레드 별로 절대 공유되어 사용되지 않음)
- 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼, 리드 버퍼 등
- 쿼리 실행 순간에만 할당 후 해제하는 공간 혹은 계속 할당된 상태로 남아있는 공간도 있음

### 플러그인 스토리지 엔진 모델

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4293750b-ee1b-4e42-9494-8dc59235d060/Untitled.png)

## 4.2 InnoDB 스토리지 엔진 아키텍처

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7826ba23-cc97-464b-b47d-d2d665ab3722/Untitled.png)

> **프라이머리 키에 의한 클러스트링**
> 
- 프라이머리 키 값의 순서대로 디스크에 저장

[[MySQL] 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/285)

> **외래 키 지원**
> 

> **MVCC(Multi Version Concurrency Control)**
> 
- 언두 로그를 이용해 이 기능 구현
- **멀티버전**: 하나의 레코드에 대해 여러 개의 버전이 동시에 관리됨
- 격리 수준이 `READ_UNCOMMITED` 인 경우
    - 데이터가 커밋됐든 아니든 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 반환
- 격리 수준이 `READ_COMMITED` 그 이상인 경우
    - 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터 반환

⇒ 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 달라지는 구조

> **잠금 없는 일관된 읽기 (Non-Locking Consistent Read)**
> 
- `SERIALIZABLE`이 아닌 다른 격리 수준에서는 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 바로 읽기 작업이 가능
- 특정 사용자가 레코드를 변경하고 커밋을 수행하지 않았다 하더라도, 다른 사용자의 읽기 작업을 방해하지 않음

⇒ 오랜 시간 동안 활성 상태인 트랜잭션으로 인해 언두 로그를 삭제하지 못하고 계속 유지해야 하므로 MySQL 서버가 느려지는 문제 발생

> **자동 데드락 감지**
> 
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 강제 종료
    - 트랜잭션의 언두 로그 양을 적게 가진 트랜잭션을 강제 종료
    - 언두 로그 레코드를 더 적게 가진 트랜잭션이 강제 롤백으로 인한 MySQL 서버 부하 덜 유발
- 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업이 부하가 될 경우
    - `innodb_deadlock_detect = off`, `innodb_lock_wait_timeout = ?s` 시스템 변수 활성화

> **자동화된 장애 복구**
> 
- 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구 수행
    - 자동으로 북구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료됨
    - `innodb_force_recovery` 시스템 변수를 설정 후 MySQL 서버 재시작

### **InnoDB 버퍼 풀**

- **버퍼 풀**
    1. 디스크의 데이터 파일이나 인덱스 정보를 **메모리에 캐시해 두는 공간**
    2. **쓰기 작업을 지연시켜** 일괄 작업으로 처리할 수 있게 해주는 **버퍼 역할**
- **버퍼 풀 크기 설정**
    - 레코드 버퍼: 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간
    - 버퍼 풀 크기는 상황에 맞춰서  변경, 버퍼 풀 크기 변경은 크리티컬한 변경이므로, 한가한 시점에 작업
    - 버퍼 풀을 인스턴스로 관리 ⇒ 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 자금 경합 유발 방지

> **버퍼 풀의 구조**
> 
- 버퍼 풀 메모리 공간을 페이지 크기의 조각으로 관리하기 위한 자료구조
    - **LRU(Least Recently Used) 리스트**
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5e0e9c5f-fcf9-40a5-8a5b-5b88605771cf/Untitled.png)
        
        - LRU(Old) + MRU(Most recently Used, New)
        - 쿼리에 의해 데이터 페이지가 사용되면 MRU 헤더 부분으로 옮겨짐
        - 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, Aging에 따라 버퍼 풀에서 제거됨
    - **플러시(Flush) 리스트**
        - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록
        - 데이터가 변경되면 리두 로그와 버퍼 풀의 데이터 페이지에 변경 내용 반영
        - 체크포인트에 리두 로그와 데이터 페이지 상태 동기화
        
        [Mysql Redo / Undo Log](https://velog.io/@pk3669/Mysql-Redo-Undo-Log)
        
    - **프리(Free) 리스트**
        - 버퍼 풀에서 비어 있는 페이지의 목록
        - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어야하는 경우 사용

> **버퍼 풀과 리두 로그**
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13507fc8-ec0d-4d7f-8e12-fea0a61bd26a/Untitled.png)

- 클린 페이지: 디스크에서 읽은 상태로 전혀 변경되지 않음
- 더티 페이지: CUD 명령으로 변경된 데이터를 가짐
    - 리두 로그는 고정 크기 파일을 연결해서 순환 고리 처럼 사용
    - 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간(활성 리두 로그)을 구분해서 관리
    - LSN(Log Sequence Number): 로그 포지션

> **버퍼 풀 플러시**
> 
- 더티 페이지 플러시(더티 페이지를 디스크에 동기화)를 성능에 악영향 없이 하는 방법
- 플러시 리스트 플러시
    - 리두 공간의 재활용을 위해 주기적으로 리두 로그 공간을 비워야 함
    - 비우긴 위해선 더티 페이지가 먼저 디스크로 동기화되어야함
    - 주기적으로 플러시 리스트 함수를 호출해서 오래전에 변경된 데이터 페이지 순서대로 동기화 작업 수행
- LRU 리스트 플러시
    - LRU 리스트에서 사용 빈도가 낮은 데이터 페이지 제거
    - LRU 리스트 끝부분부터 페이지 스캔하면서 더티 페이지는 디스크에 동기화, 클린 페이지는 프리 리스트

> **버퍼 풀 상태 백업 및 복구**
> 
- **워밍업**: 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태
- MySQL 서버 재시작하는 경우 InnoDB 버퍼 풀의 상태 백업
- 버퍼 풀의 적재 내용 확인 (`information_schema`)

### Double write Buffer

> **Double-Write 기법**
> 
- 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 리두 로그에 기록
- 디스크 파일로 플러시할 때 일부만 기록되는 현상 발생 ⇒ 파셜 페이지, 톤 페이지
- 작동 방식
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df1b41d2-4fcb-47d5-9945-0c98650ee50a/Untitled.png)
    
    1. ‘A’ ~ ‘E’ 까지의 더티 페이지를 DoubleWrite 버퍼에 기록
    2. 데이터 페이지를 개별로 파일로 기록
    3. InnoDB 스토리지 엔진은 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 담고 있는 경우 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사

### 언두 로그

- CUD로 데이터를 변경했을 때 이전 데이터를 보관하는 곳
- **트랜잭션 보장**: 트랜잭션 롤백
- **격리 수준 보장**: 데이터 변경 중 다른 커넥션에서 데이터 조회 시
- 언두 로그 저장 공간: (이전) 언두 테이블스페이스 → (현재) 언두 로그 파일

### 체인지 버퍼

- 변경할 인덱스 페이지가 버퍼 풀에 없어 디스크로부터 읽어와서 업데이트 하는 경우
- 즉시 실행하지 않고 임시 공간(체인지 버퍼)에 저장해두고 사용자에게 바로 결과를 반환하는 형태
- 체인지 버퍼 머지 스레드: 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합

### 리두 로그 및 로그 버퍼

- 데이터 변경 내용을 로그로 먼저 기록
- 쓰기 성능 < 읽기 성능을 고려한 자료 구조
    - 데이터 변경은 상대적으로 큰 비용 필요 → 성능 저하를 막기 위해 쓰기 비용이 낮은 리두 로그 사용
- MySQL 서버가 비정상 종료되는 경우
    - 커밋됐지만 데이터 파일에 기록되지 않은 데이터
    - 롤백됐지만 데이터 파일에 이미 기록된 데이터
- 리두 로그 아카이빙: 리두 로그가 덮어쓰이는 경우
- 리두 로그 활성화 및 비활성화: 비활성화는 잘 고려해서 쓰자

### 어댑티브 해시 인덱스

- InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- B-Tree 검색 시간을 줄여주기 이해
- 자주 읽히는 데이터 페이지의 키 값을 이용해 **해시 인덱스**를 만듬
    - 인덱스 키 값: B-Tree 인덱스 고유번호
    - 인덱스 키 값이 저장된 데이터 페이지 주소 쌍: 실제 키 값이 저장된 데이터 페이지의 메모리 주소
        - 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리됨
        - ⇒ 버퍼 풀에서 사라지면 해시 인덱스에서도 사라짐
- 파티션 기능 제공
- 필요에 따라 잘 사용해야함
    - 테이블 삭제 및 변경 작업의 경우 해시 인덱스에서도 모두 제거해야하므로 치명적인 작업

## 4.3 MyISAM 스토리지 엔진 아키텍처

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/07b4c974-2af3-42e6-ba6d-5a2d5e9a0bf5/Untitled.png)

### 키 캐시

### 운영체제의 캐시 및 버퍼

### 데이터 파일과 프라이머리 키(인덱스) 구조

## 4.4 MySQL 로그 파일

### 에러 로그 파일

### 제너럴 쿼리 로그 파일

- 시간 단위로 실행됐던 쿼리 내용 모두 기록

### 슬로우 쿼리 로그

- 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리 기록
- 서비스에서 사용되는 쿼리 중에서 어떤 쿼리가 문제인지 판단하는데 사용