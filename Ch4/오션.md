# Ch4

## 4.1 MySQL 엔진 아키텍처

MySQL 서버는 다른 DBMS와 구조가 독특하다. 이런 독특함 때문에 다른 DBMS 대비 엄청난 혜택 및 문제가 발생한다.

### 4.1.1.1 MySQL 엔진

클라이언트로부터 접속 및 쿼리 요청을 처리하는 **커넥션 핸들러, SQL 파서, 전처리기, 옵티마이저**가 중심을 이룬다.

### 4.1.1.2 스토리지 엔진

실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이전담한다. MySQL 서버에서 **MySQL 엔진은 하나 지만, 스토리지 엔진은 여러개**를 사용할 수 있다.

각 스토리지 엔진은 성능 향상을 위해 키캐시(MyISAM 스토리지 엔진), InnoDB 버퍼풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다.

### 4.1.1.3 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰고, 읽을 때 각 스토리지 엔진에 쓰기,읽기 요청을 한다. 이 요청을 핸들러 요청이라 하며, 사용되는 API를 핸들러 API라고 한다. 핸들러 API와 MySQL엔진과 데이터를 주고받는다.

여기서 핸들러 라는 것은 결국 스토리지 엔진을 의미한다. InnoDB 테이블을 조작하는 경우 핸들러가 InnoDB 스토리지 엔진이 된다. MySQL엔진과 스토리지 엔진 간 전송을 위해 사용되는 것이 핸들러 API 라고 할 수 있다.

---

## 4.1.2 MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아니라 **스레드** 기반으로 작동하며, **포그라운드, 백그라운드 스레드**로 구분할 수 있다.

<aside>
💡 프로세스 기반이라는 것은 하나의 프로세스는 한 작업을 수행하고 각각 프로세스는 서로 독립적으로 실행된다. 그럴 경우 각 요청이 독립된 프로세스에서 작동되며, 프로세스간 별도 통신 방법이 필요하고 자원을 많이 잡아먹는다.
하지만 스레드 기반 아키텍처는 클라이언트 요청을 독립적으로 처리하는데 효과적이며, 여러 클라이언트 요청을 동시에 처리하기에도 용이하다. 메모리 영역을 공유하기에 통신이 쉽고 자원을 많이 잡아먹지 않는다.
</aside>

백그라운드 스레드의 개수는 MySQL 서버의 설정에 따라 가변적일 수 있다. 동일한 스레드는 여러 스레드가 **동일 작업을 병렬**로 처리하기 때문에 나타날 수 있다.

### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

각 클라이언트 사용자가 요청하는 쿼리 문장을 처리하며, 최소 MySQl 서버에 접속된 클라이언트 수만큼 존재한다. 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져온다. 존재하지 않을 경우 디스크, 인덱스 파일로부터 데이터를 읽어와서 처리한다.

작업을 마치고 커넥션을 종료하면, 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아간다. 스레드 캐시에 일정 개수 이상 대기중인 스레드가 있다면 캐시에 넣지 않고 스레드를 종료시킨다. 이는 `thread_cache_size` 시스템 변수로 설정한다.

### 4.1.2.2 백그라운드 스레드

MyISAM은 해당사항이 없지만, InnoDB는 다음과 같은 작업이 백그라운드로 처리된다.

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

### 스토리지 엔진 별 스레드 역할

**MyISAM**

디스크 쓰기 작업까지 포그라운드 스레드가 처리

**InnoDB**

데이터 버퍼, 캐시까지만 포그라운드 스레드가 처리하며, 나머지 버퍼로부터 디스크까지 기록은 백그라운드 스레드가 처리한다.

---

## 4.1.3 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역, 로컬 메모리 영역으로 구분된다.

### 4.1.3.1 글로벌 메모리 영역

글로벌 메모리 영역은 MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 할당받는 것 이다.

스레드 수와 별개로 하나의 메모리 공간만 할당한다. 생성된 글로벌 영역은 전역적으로 모든 스레드에 의해 공유된다.

- 테이블 캐시
    - 데이터베이스 테이블에 대한 메타데이터와 데이터 페이지를 캐시하여 빠른 데이터 액세스와 성능 향상을 위해 사용된다.
- InnoDB 버퍼 풀
    - 데이터와 인덱스 페이지를 캐싱해 놓고 디스크 접근을 최소화하며 성능 향상을 위해 사용된다.
- InnoDB 어댑티브 해시 인덱스
    - 효율적인 메모리 기반 인덱스 구조이다.
- InnoDB 리두 로그 버퍼
    - 데이터베이스의 변경 사항을 임시로 기록하여 데이터의 일관성과 내구성을 보장하는 역할을 한다.

### 4.1.3.2 로컬 메모리 영역

세션 메모리 영역이라고도 표현한다. 클라이언트와 MySQL 서버와의 커넥션을 세션이라고한다.

스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. 절대 공유되어 사용되지 않는다. 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차 하지 않을 수 있다.

- 정렬 버퍼
    - 정렬 작업을 수행하기 위해 임시로 데이터를 저장하는 용도로 사용된다.
- 조인 버퍼
    - MySQL 데이터베이스에서 사용되는 메모리 영역으로, 조인 연산을 수행하는 동안 임시로 데이터를 저장하고 처리하는 데 사용된다.
- 바이너리 로그 캐시
    - 데이터베이스의 변경 사항을 기록하는 로그 파일을 임시로 저장하는 용도로 사용된다.
- 네트워크 버퍼
    - 컴퓨터 네트워크에서 데이터를 임시로 저장하는 메모리 영역이다.

---

## 4.1.4 플러그인 스토리지 엔진 모델

플러그인 형태로 개발해서 사용가능하다.

MySQL 엔진은 **반드시 핸드러를 통해**야 한다.

### MyISAM, InnoDB 차이

하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데 각 하위 작업이 MySQL 엔진 영역에서 처리되는지, 아니면 스토리지 엔진 영역에서 처리되는지 구분할 수 있어야 한다.

---

## 4.1.5 컴포넌트

MySQL 8.0 부터 플러그인 아키텍처 대신 컴포넌트 아키텍처가 지원된다.

단점으로는 **플러그인 끼리 통신 못하며, 캡슐화가 되지 않고, 초기화가 어렵다**는 단점이 있었다.

---

## 4.1.6 쿼리 실행 구조

![Untitled](https://github.com/woowacourse-study/2023-DB-Study-BE/assets/86547109/6daac945-de20-4a7e-8df8-668b75cdb5de)

### 4.1.6.1 쿼리 파서

쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어내는 작업이다.

![Untitled](https://github.com/woowacourse-study/2023-DB-Study-BE/assets/86547109/0572f4b2-d644-4f9f-92ab-756699d882dc)

### 4.1.6.2 전처리기

파서 과정에서 트리를 기반으로한 문장에 구조적인 문제가 없는지 확인한다. 객체 존재여부, 객체접근권한등을 확인한다.

### 4.1.6.3 옵티마이저

요청 쿼리를 저렴한 비용으로 가장 빠르게 처리할지 담당한다.

### 4.1.6.4 실행엔진

각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

### 4.1.6.5 핸들러

MySQl 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 담당한다. 결국 스토리지 엔진을 의미한다.

### 4.1.8 쿼리 캐시

동일 쿼리 실행시 즉시 결과 반환할 수 있기에 좋은 성능이지만 데이터 변경시 관련된 것들은 모두 삭제해야해서 **동시처리 성능 저**하를 유발했다. 8.0 버전에서는 완전히 제거되었다.

### 4.1.9 스레드 풀

엔터프라이즈 에디션에서 사용가능하다. 내부적으로 사용자 요청을 처리하는 스레드 개수를 줄여 제한된 개수의 스레드 처리에만 집중할 수 있도록 하여 서버 자원 소모를 줄인다. cpu가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빠르게 처리. thread_pool_stall_limit 시스템 변수를 통해 새 쓰레드를 추가할지 기다릴지를 결정한다.

### 4.1.10 트랜잭션 지원 메타데이터

기존에는 파일 기반 메타데이터를 사용하였으나 트랜잭션을 지원하지 않기 때문에 MySQL이 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 있었다.

현재는 InnoDB의 테이블에 저장하도록 개선하였다.

---

## 4.2 InnoDB 스토리지 엔진 아키텍처

스토리지 엔진 중 유일하게 **레코드 기반 잠금을 제공하고, 높은 동시성 처리가 가능하고, 안정적이며 성능이 뛰어**나다.

![Untitled](https://github.com/woowacourse-study/2023-DB-Study-BE/assets/86547109/2a240e47-9172-4f09-aaa6-aa22739d828d)

### 4.2.1 프라이머리 키에 의한 클러스터링

모든 테이블은 PK를 기준으로 클러스터링(PK 순으로 디스크에 저장) 되어 저장된다.

MyISAM 엔진은 지원하지 않는다.

### 4.2.2 외래키 지원

InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다. 변경 시 부모, 자식 테이블에 데이터가 있는지 체크하기에 잠금이 여러 테이블로 전파되고 데드락이 발생할 수 있다. 일시적으로 `foreign_key_checks`를 통해 키 체크 작업을 멈출 수 있다.

### 4.2.3 MVCC

잠금을 사용하지 않는 일관된 읽기를 제공한다.

격리 수준에 따라 조회되는 결과 값이 다를 수 있다. READ_UNCOMMITTED 는 InnoDB 버퍼의 데이터를 읽어서 반환한다. 그 외의 격리 수준은 아직 커밋되지 않았기 때문에 Undo 영역의 데이터를 반환한다.

하나의 레코드에 대해 2개의 버전이 유지되고 필요에 따라 어느 데이터가 보여지는지 달라지는 구조이다.

### 4.2.4 잠금 없는 일관된 읽기

InnoDB 스토리지 엔진은 잠금을 걸지 않기에 다른 트랜잭션의 잠금을 기다리지 않고 읽기가 가능하다. Serializable을 제외하고는 가능하다.

계속해서 undo log를 유지한다면 문제가 발생할 수 있다. 트랜잭션이 시작되면 롤백,커밋을 통해 완료해야한다.

### 4.2.5 자동 데드락 감지

내부적으로 잠금 대기 목록을 그래프 형태로 관리하여 교착상태를 체크한다. 주기적으로 교착상태의 트랜잭션을 강제 종료한다.

이때 종료 기준은 언두 로그 양이며, 언두 레코드를 더 적게 가진 트랜잭션이 롤백의 대상이 된다. 적을 수록 롤백할 내용이 적기에 서버 부하가 덜 유발되서 그렇다.

### 4.2.6 자동화된 장애 복구

InnoDB 스토리지 엔진은 데이터 파일이 손상되거나, MySQL 서버가 시작되지 못하는 경우는 거의 없다.

### 4.2.7 InnoDB 버퍼 풀

디스크의 데이터 파일, 인덱스 정보를 메모리에 캐시해 두는 공간이다. 쓰기 작업 지연으로 버퍼역할도 한다. 일반적인 랜덤 디스크 조회 비용보다 모아서 처리하기 때문에 훨씬 비용이 싸다.

### 4.2.7.1 버퍼 풀의 크기 설정

적절한 작은 값으로 시작해서 증가시키는 방법이 최적이다. `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있다.

### 4.2.7.2 버퍼 풀의 구조

버퍼 풀은 설정한 페이지 크기의 조각으로 쪼개져 있다. 여러 조각으로 관리하여 락을 관리한다.

LRU(최근에 사용,접근 되었는가를 판단) , FLUSH, FREE(비어있는 페이지 리스트) 3가지 자료구조를 관리한다.

### 4.2.7.3 버퍼 풀과 리두 로그

버퍼 풀에는 Clean,Dirty Page를 관리할 수 있다. 데이터 변경이 계속 발생 될 경우 리두 로그 파일에 기록된 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다. . . (?)

### 4.2.7.4 버퍼 풀 플러시

버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 실행했다.

플러시 리스트 플러시

LRU 리스트 플러시

여기 왜이리 어려움 ?

### 4.2.8 Double Write Buffer

InnoDB 스토리지 엔진의 리두로그는 공간 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 그래서 플러시 하는 중에 문제가 발생하면 복구할 수 없다. 이 문제를 해결하기 위해 Double-Write 기법을 이용한다.

플러시될 페이지를 DoubleWrite 버퍼에 기록하고 디스크에 기록한다. 후에 버퍼와 디스크 내용이 다를 경우 같게 쓴다.

### 4.2.9 언두 로그

트랜잭션, 격리수준을 보장하기 위해 DML 변경 이전에 데이터를 별도로 백업한다. 이렇게 백업한 데이터를 언두 로그라고 한다.

- 트랜잭션 보장
- 격리 수준 보장

### 4.2.10 체인지 버퍼

데이터 파일 뿐 아니라 해당 인덱스도 업데이트 해야한다. 버퍼 풀에 있을 경우 바로 업데이트, 아닐 경우 즉시 실행하지 않고 임시 공간에 저장하고 결과를 반환한다.

Unique할 경우 사용할 수 없다.

### 4.2.11 리두 로그 및 로그 버퍼

리두 로그는 서버 비정상 종료 시 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 것이다.
